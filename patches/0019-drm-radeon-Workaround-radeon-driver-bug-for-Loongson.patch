From 53472cfdfbb49c5f5cd2fae0b26da28e5a8ba376 Mon Sep 17 00:00:00 2001
From: Huacai Chen <chenhuacai@loongson.cn>
Date: Mon, 22 Feb 2021 10:53:47 +0800
Subject: [PATCH 19/24] drm/radeon: Workaround radeon driver bug for Loongson

Radeon driver can not handle the interrupt is faster than DMA data, so
irq handler must update an old ih.rptr value in IH_RB_RPTR register to
enable interrupt again when interrupt is faster than DMA data.

Signed-off-by: Huacai Chen <chenhuacai@loongson.cn>
Signed-off-by: Zhijie Zhang <zhangzhijie@loongson.cn>
---
 drivers/gpu/drm/radeon/cik.c       | 1 +
 drivers/gpu/drm/radeon/evergreen.c | 1 +
 drivers/gpu/drm/radeon/r600.c      | 1 +
 drivers/gpu/drm/radeon/si.c        | 1 +
 4 files changed, 4 insertions(+)

diff --git a/drivers/gpu/drm/radeon/cik.c b/drivers/gpu/drm/radeon/cik.c
index 0c5bdf87e..19ae47147 100644
--- a/drivers/gpu/drm/radeon/cik.c
+++ b/drivers/gpu/drm/radeon/cik.c
@@ -8090,6 +8090,7 @@ int cik_irq_process(struct radeon_device *rdev)
 	if (queue_thermal)
 		schedule_work(&rdev->pm.dpm.thermal.work);
 	rdev->ih.rptr = rptr;
+	WREG32(IH_RB_RPTR, rptr);
 	atomic_set(&rdev->ih.lock, 0);
 
 	/* make sure wptr hasn't changed while processing */
diff --git a/drivers/gpu/drm/radeon/evergreen.c b/drivers/gpu/drm/radeon/evergreen.c
index bc4ab7161..1ce165c62 100644
--- a/drivers/gpu/drm/radeon/evergreen.c
+++ b/drivers/gpu/drm/radeon/evergreen.c
@@ -4919,6 +4919,7 @@ int evergreen_irq_process(struct radeon_device *rdev)
 	if (queue_thermal && rdev->pm.dpm_enabled)
 		schedule_work(&rdev->pm.dpm.thermal.work);
 	rdev->ih.rptr = rptr;
+	WREG32(IH_RB_RPTR, rptr);
 	atomic_set(&rdev->ih.lock, 0);
 
 	/* make sure wptr hasn't changed while processing */
diff --git a/drivers/gpu/drm/radeon/r600.c b/drivers/gpu/drm/radeon/r600.c
index 8b62f7faa..88e38fb3f 100644
--- a/drivers/gpu/drm/radeon/r600.c
+++ b/drivers/gpu/drm/radeon/r600.c
@@ -4328,6 +4328,7 @@ int r600_irq_process(struct radeon_device *rdev)
 	if (queue_thermal && rdev->pm.dpm_enabled)
 		schedule_work(&rdev->pm.dpm.thermal.work);
 	rdev->ih.rptr = rptr;
+	WREG32(IH_RB_RPTR, rptr);
 	atomic_set(&rdev->ih.lock, 0);
 
 	/* make sure wptr hasn't changed while processing */
diff --git a/drivers/gpu/drm/radeon/si.c b/drivers/gpu/drm/radeon/si.c
index 26197aceb..2d7eeb781 100644
--- a/drivers/gpu/drm/radeon/si.c
+++ b/drivers/gpu/drm/radeon/si.c
@@ -6423,6 +6423,7 @@ int si_irq_process(struct radeon_device *rdev)
 	if (queue_thermal && rdev->pm.dpm_enabled)
 		schedule_work(&rdev->pm.dpm.thermal.work);
 	rdev->ih.rptr = rptr;
+	WREG32(IH_RB_RPTR, rptr);
 	atomic_set(&rdev->ih.lock, 0);
 
 	/* make sure wptr hasn't changed while processing */
-- 
2.51.2


From 0957374e50edce74960ce2a1cb6c442a44cf29c1 Mon Sep 17 00:00:00 2001
From: Mingcong Bai <jeffbai@aosc.io>
Date: Wed, 26 Nov 2025 22:21:05 +0800
Subject: [PATCH 07/24] AOSCOS: loongarch: re-introduce add_numamem_region(),
 init_node_memblock()

This is a partial revert for commit acf5de1b23b0 ("LoongArch: Fix NUMA
node parsing with numa_memblks") to keep our BPI/legacy firmware patches
working.

Further testing and refactoring (and perhaps discussion) pending.

Signed-off-by: Mingcong Bai <jeffbai@aosc.io>
---
 arch/loongarch/kernel/numa.c | 67 ++++++++++++++++++++++++++++++++++++
 1 file changed, 67 insertions(+)

diff --git a/arch/loongarch/kernel/numa.c b/arch/loongarch/kernel/numa.c
index 8b89898e2..3efd2b4fe 100644
--- a/arch/loongarch/kernel/numa.c
+++ b/arch/loongarch/kernel/numa.c
@@ -158,8 +158,75 @@ static void __init node_mem_init(unsigned int node)
 
 #ifdef CONFIG_ACPI_NUMA
 
+/*
+ * add_numamem_region
+ *
+ * Add a uasable memory region described by BIOS. The
+ * routine gets each intersection between BIOS's region
+ * and node's region, and adds them into node's memblock
+ * pool.
+ *
+ */
+static void __init add_numamem_region(u64 start, u64 end, u32 type)
+{
+	u32 node = pa_to_nid(start);
+	u64 size = end - start;
+	static unsigned long num_physpages;
+
+	if (start >= end) {
+		pr_debug("Invalid region: %016llx-%016llx\n", start, end);
+		return;
+	}
+
+	num_physpages += (size >> PAGE_SHIFT);
+	pr_info("Node%d: mem_type:%d, mem_start:0x%llx, mem_size:0x%llx Bytes\n",
+		node, type, start, size);
+	pr_info("       start_pfn:0x%llx, end_pfn:0x%llx, num_physpages:0x%lx\n",
+		start >> PAGE_SHIFT, end >> PAGE_SHIFT, num_physpages);
+	memblock_set_node(start, size, &memblock.memory, node);
+}
+
 static unsigned long num_physpages;
 
+static void __init init_node_memblock(void)
+{
+	u32 mem_type;
+	u64 mem_end, mem_start, mem_size;
+	efi_memory_desc_t *md;
+
+	/* Parse memory information and activate */
+	for_each_efi_memory_desc(md) {
+		mem_type = md->type;
+		mem_start = md->phys_addr;
+		mem_size = md->num_pages << EFI_PAGE_SHIFT;
+		mem_end = mem_start + mem_size;
+
+		switch (mem_type) {
+		case EFI_LOADER_CODE:
+		case EFI_LOADER_DATA:
+		case EFI_BOOT_SERVICES_CODE:
+		case EFI_BOOT_SERVICES_DATA:
+		case EFI_PERSISTENT_MEMORY:
+		case EFI_CONVENTIONAL_MEMORY:
+			add_numamem_region(mem_start, mem_end, mem_type);
+			break;
+		case EFI_PAL_CODE:
+		case EFI_UNUSABLE_MEMORY:
+		case EFI_ACPI_RECLAIM_MEMORY:
+			add_numamem_region(mem_start, mem_end, mem_type);
+			fallthrough;
+		case EFI_RESERVED_TYPE:
+		case EFI_RUNTIME_SERVICES_CODE:
+		case EFI_RUNTIME_SERVICES_DATA:
+		case EFI_MEMORY_MAPPED_IO:
+		case EFI_MEMORY_MAPPED_IO_PORT_SPACE:
+			pr_info("Resvd: mem_type:%d, mem_start:0x%llx, mem_size:0x%llx Bytes\n",
+					mem_type, mem_start, mem_size);
+			break;
+		}
+	}
+}
+
 static void __init info_node_memblock(void)
 {
 	u32 mem_type;
-- 
2.51.2

